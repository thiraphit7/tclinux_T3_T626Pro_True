#!/usr/bin/env python3
"""
Crack romfile using known-plaintext attack

Since the key doesn't repeat cyclically, we need to find enough
known plaintext to extract the full keystream.
"""

import sys

def main():
    filepath = sys.argv[1] if len(sys.argv) > 1 else '/home/user/tclinux_T3_T626Pro_True/romfile.cfg.txt'

    with open(filepath, 'rb') as f:
        encrypted = f.read()

    # Load reference plaintext
    ref_path = '/home/user/tclinux_T3_T626Pro_True/hybrid_build/stock_root/userfs/romfile_f.cfg'
    with open(ref_path, 'rb') as f:
        reference = f.read()

    print(f"Encrypted: {len(encrypted)} bytes")
    print(f"Reference: {len(reference)} bytes")

    # The encrypted file is larger. Options:
    # 1. It's a different config (from actual router backup)
    # 2. It has header/padding
    # 3. It's base64 encoded after XOR

    # Let's check if the reference is contained somewhere or if there's a header

    # Common romfile XML patterns we can search for
    known_patterns = [
        (b'<ROMFILE> \n<Wan>\n\t<Common ReConnect="1" ', 0),
        (b'WANAccessType="', None),  # Unknown position
        (b'</ROMFILE>', None),
        (b'GPON_ONU', None),
        (b'SerialNumber=', None),
        (b'VendorId=', None),
    ]

    # Try to find patterns at the start
    print("\n" + "=" * 60)
    print("KNOWN PLAINTEXT ATTACK")
    print("=" * 60)

    # We know it starts with <ROMFILE>
    # Calculate keystream from first 60 bytes of expected plaintext
    expected_start = b'<ROMFILE> \n<Wan>\n\t<Common ReConnect="1" WANAccessType="'

    print(f"\nExpected start ({len(expected_start)} bytes):")
    print(expected_start.decode('ascii', errors='replace'))

    # Extract keystream
    keystream = bytes(encrypted[i] ^ expected_start[i] for i in range(len(expected_start)))

    print(f"\nKeystream (first {len(keystream)} bytes):")
    print(' '.join(f'{b:02x}' for b in keystream))

    # Check if keystream has a pattern
    print("\nLooking for patterns in keystream...")

    # Check for LFSR or simple patterns
    for period in [4, 8, 12, 16, 20, 24, 28, 32]:
        matches = sum(1 for i in range(period, len(keystream)) if keystream[i] == keystream[i % period])
        if matches > 0:
            print(f"  Period {period}: {matches}/{len(keystream)-period} matches")

    # The keystream might be generated by a simple algorithm
    # Let's check if it looks like RC4 or similar

    # Since we know the first ~60 bytes of keystream, try to decrypt more
    print("\n" + "=" * 60)
    print("PARTIAL DECRYPTION")
    print("=" * 60)

    # Decrypt what we can with known keystream
    partial_decrypted = bytes(encrypted[i] ^ keystream[i] for i in range(len(keystream)))
    print(f"First {len(keystream)} bytes decrypted:")
    print(partial_decrypted.decode('ascii', errors='replace'))

    # Now try to extend the keystream by guessing the next plaintext
    # After the position we know, we can guess common XML patterns

    # Position after WANAccessType="
    pos = len(expected_start)

    # Typical values after WANAccessType=" are: "0", "1", "GPON", "xDSL", etc.
    test_continuations = [
        b'0" ',
        b'1" ',
        b'2" ',
        b'GPON" ',
        b'xDSL" ',
    ]

    print(f"\nTesting continuations at position {pos}:")
    for cont in test_continuations:
        test_key = bytes(encrypted[pos + i] ^ cont[i] for i in range(len(cont)))
        print(f"  '{cont.decode()}' -> keystream: {test_key.hex()}")

    # Try a longer known plaintext approach
    # Based on romfile_f.cfg structure
    print("\n" + "=" * 60)
    print("EXTENDED DECRYPTION ATTEMPT")
    print("=" * 60)

    # Read more of the reference to get a longer known plaintext
    with open(ref_path, 'rb') as f:
        full_ref = f.read()

    # The encrypted file is 153120 bytes, reference is 48161
    # Ratio: 3.18x - this suggests base64 encoding!
    # Base64 expands by 4/3 = 1.33x, but 3.18x is close to 3x...

    # Actually wait - let me check if the encrypted file might be
    # the plaintext but with each byte XOR'd with something that changes

    # Let's try: if we XOR encrypted with a repeating pattern, can we get XML?
    # Or maybe it's just a different config file entirely

    # Search for XML patterns in the encrypted data after XOR with various constants
    print("\nSearching for patterns in encrypted data...")

    # The pattern we see: lots of uppercase letters and numbers
    # This looks like some kind of custom encoding

    # Let's check if it might be custom base64
    print("\nChecking character distribution in encrypted file:")
    from collections import Counter
    counter = Counter(encrypted)

    # Check if it uses a limited charset (base64-like)
    used_chars = len([c for c, cnt in counter.items() if cnt > 0])
    print(f"Unique byte values: {used_chars}")

    # In standard base64, there are 64 chars + padding = 65
    # If used_chars is around 64-80, it might be base64-like

    if used_chars < 100:
        print("Limited charset - possibly base64-like encoding")

        # Build the charset used
        charset = bytes(sorted([b for b in counter.keys()]))
        print(f"Charset: {charset[:64]}")

    # Final attempt: Just use the keystream we have and see how far we can go
    # by guessing common XML elements

    print("\n" + "=" * 60)
    print("BEST EFFORT DECRYPTION")
    print("=" * 60)

    # Build longest possible keystream from guessing
    # Known XML structure from romfile_f.cfg:

    guessed_plaintext = b'''<ROMFILE>
<Wan>
\t<Common ReConnect="1" WANAccessType="'''

    # Try some common values
    for wan_type in [b'0', b'1', b'2', b'GPON']:
        test_plain = guessed_plaintext + wan_type + b'"'
        test_keystream = bytes(encrypted[i] ^ test_plain[i] for i in range(len(test_plain)))

        # Continue decrypting with this keystream repeated
        # No - the keystream doesn't repeat

        # Just show what we get
        test_decrypt = bytes(encrypted[i] ^ test_keystream[i % len(test_keystream)] for i in range(min(500, len(encrypted))))
        valid_xml = all(32 <= b < 127 or b in [9, 10, 13] for b in test_decrypt[:200])

        if valid_xml:
            print(f"\nWAN type '{wan_type.decode()}' produces valid ASCII for first 200 bytes:")
            print(test_decrypt[:200].decode('ascii', errors='replace'))

if __name__ == '__main__':
    main()
